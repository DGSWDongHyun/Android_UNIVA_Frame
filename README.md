# Mobile_UNIVA_Frame

## ExampleFlutter
유니바에서 플러터 어플리케이션을 제작할 경우 프레임으로 활용할 수 있는 예제입니다.

아래는 활용된 기술 스택입니다.

- GetX
  - 의존성 주입에 활용된 라이브러리입니다. 처음 메모리 초기화시에 인스턴스를 함께 초기화하고, 이후 인스턴스를 주입해주는 방식으로 활용하였습니다.
  - Navigation에 많은 자원을 들이지 않기 위해 추가한 목적도 존재합니다.
  
- CleanArchitecture
  - 아키텍쳐는 안드로이드와 동일하게 클린 아키텍쳐를 진행하였습니다. 테스트 커버리지를 넓히기 위해서도 해당 방안을 채택하였습니다.
 
- MVVM
  - Provider, GetX가 활용되기 위해 참고한 이론입니다.
  - 유지보수 및 테스트 커버리지 증대를 위해 디자인한 패턴입니다.

- Provider
  - 위젯에서의 setState를 최소화 시키기 위해 추상적인 ViewModel 개념으로 도입된 라이브러리입니다. ViewModel과 비슷한 방식이며 해당 라이브러리를 통해 위젯이 단순 재빌드 될 때, 값을 옵저빙하여 받아온 후에 적용하는 방식입니다.
  - 해당 라이브러리를 채택함으로써, 페이징의 대부분은 Stateless 형태로 처리합니다.

## ExampleCompose
유나바에서 안드로이드 어플리케이션을 제작할 경우 프레임으로 활용할 수 있는 예제입니다.

아래는 활용된 기술 스택입니다.

- Jetpack Compose ( 젯팩 컴포즈 )
  - 더 이상 xml과 Kotlin을 각각 이용할 필요가 없습니다.
  - 최근 선언형 프로그래밍이 유행하기 때문에 채택하였습니다. ( ex. Flutter / Swift UI )
  
- MVVM
  - 유지보수형에 적합한 패턴입니다.
  - 프레임의 기본적인 예시, 대부분의 경우에는 해당 디자인 패턴을 사용하지만, 특이한 케이스 ( 예외적으로 너무 많은 테스트 코드가 필요할때, 혹은 더욱 효율적인 코드가 필요할때 ) 에는 해당 프레임을 MVP로 변환하셔도 좋습니다.

- Coroutines
  - 비동기 처리 라이브러리로, 구글에서 자체 제작한 AsyncTask를 대신하여주는 라이브러리입니다. RxJava와 달리 초반 러닝 커브가 깊지 않기 때문에 채택하였습니다.
  
- CleanArchitecture
  - 디자인 패턴 MVVM과 함께 사용되는 아키텍쳐 방식입니다. data, domain, presentation 레이어를 세부적으로 분리하여 각각의 레이어에 맞게 클래스 작성 / 의존 관계도를 확인하여 implementation을 진행해주시면 됩니다.

모든 프로젝트는 케이스 바이 케이스입니다. 전담받은 회사 프로젝트들의 모든 프레임을 위 프레임으로 적용할 필요가 없으며, 상황에 따라는 가장 원시적인 MVC 모델도 활용하셔도 됩니다. 
